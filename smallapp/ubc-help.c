// Copyright (c) 2021 Secure64 Software
// All Rights Reserved
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice,
//   this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
// * Neither the name of Secure64 Software nor the names of its contributors
//   may be used to endorse or promote products derived from this software
//   without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// ubc-help [ spec.xml ... ]
//
//	Extract the help information from the unbound control XML description
//	and put generate a source file to include in unbound-control

#include "ubc-xml.h"

#define CMD_WIDTH 26
#define MAKE_STR(v) #v
#define VSTR(v) MAKE_STR(v)

static char const *prologue =
"// THIS FILE IS AUTOMATICALLY GENERATED\n"
"// DO NOT EDIT, MODIFY, COMMIT, ARCHIVE!\n"
"// LOOK AT smallapp/ubc.xml FOR MORE INFORMATION\n\n"
"struct cmd_info {\n"
"\tchar const *cmd;\n"
"\tchar const *info;\n"
"};\n"
"\n"
"static void\n"
"helpList(void)\n"
"{\n"
"\tstatic const struct cmd_info commandList[] = {";

static char const *epilogue =
"\t\t{ NULL, NULL }\n"
"\t};\n"
"\n"
"\tstruct cmd_info const *cip = commandList;\n"
"\tchar const *cmd;\n"
"\n"
"\twhile ((cmd = cip->cmd) != NULL) {\n"
"\t\tprintf(\"  %-" VSTR(CMD_WIDTH) "s%s\\n\",\n"
"\t\t       cmd,\n"
"\t\t       cip->info);\n"
"\t\tcip++;\n"
"\t}\n"
"}";

static int ifdef  = 0;

#define	NO_LINES   0
#define	FIRST_LINE 1
#define	NEXT_LINE  2

void XMLCALL
xmlStart(void *udata, const XML_Char *name, const XML_Char **attrs)
{
	struct parser_data *pdp = udata;

	if (strcmp(name, "CmdHelp") == 0) {
		XML_Char const *ap, *vp;

		if ((ap = *attrs++) == NULL) {
			ifdef = 0;
		} else {
			vp = *attrs;

			if (strcmp(ap, "ifdef") == 0) {
				fprintf(pdp->out, "#if defined(" XML_STR("") ")\n", vp);
			} else if (strcmp(ap, "ifndef") == 0) {
				fprintf(pdp->out, "#if !defined(" XML_STR("") ")\n", vp);
			} else {
				fprintf(pdp->err, "Unknown attribute " XML_STR("")
				                  "=" XML_STR("") "\n",
				                  ap,
				                  vp);
				exit(1);
			}

			ifdef = 1;
		}

		// Start copying output

		pdp->flags = FIRST_LINE;
	} else if (strcmp(name, "CommandList") == 0) {
		fprintf(pdp->out, "%s\n", prologue);
	}
}

void XMLCALL
xmlEnd(void *udata, const XML_Char *name)
{
	struct parser_data *pdp = udata;

	if (strcmp(name, "Command") == 0) {
		clrCommandInfo(pdp);
	} else if (strcmp(name, "CmdHelp") == 0) {
		if (ifdef) {
			fprintf(pdp->out, "#endif\n");
			ifdef = 0;
		}
			
		pdp->flags = NO_LINES;
	} else if (strcmp(name, "CommandList") == 0) {
		fprintf(pdp->out, "%s\n", epilogue);
	}
}

void
xmlComment(void *udata, const XML_Char *info)
{
}

void
xmlText(void *udata, const XML_Char *info, int len)
{
	struct parser_data *pdp = udata;

	if (pdp->flags == NO_LINES) {
		return;
	}

	fprintf(pdp->out, "\t\t{\n");

	if (pdp->flags == FIRST_LINE) {
		fprintf(pdp->out, "\t\t\t\"%s\",\n", pdp->command);
		pdp->flags = NEXT_LINE;
	} else {
		fprintf(pdp->out, "\t\t\t\"\",\n");
	}

	fprintf(pdp->out, "\t\t\t\"");

	if (len > 0) {
		do {
			fprintf(pdp->out, XML_STR("1.1"), info++);
		} while (len-- != 1);
	}

	fprintf(pdp->out, "\"\n\t\t},\n");
}
